## 锁对比
### golang mutex
#### 背景
- golang已经拿到读锁再次进入读锁需要等写锁这个逻辑。
#### 结果
- 导致一些场景死锁
#### 解决办法
- 需要代码健壮性更强
#### 抑或
- golang本来就存在这个bug

### Java mutex
- 不存在golang锁的问题

## 结语：
- Go的设计者比较「偏执」，认为「不好」的设计坚决不去实现，就如锁的实现不应该依赖线程、协程信息；可重入（递归）锁是一种不好的设计。所以这种看似有BUG的设计，也存在一定的道理。
